import asyncio
import logging
import re
from datetime import datetime
import random

import aioschedule

from aiogram import Bot, Dispatcher, executor, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import StatesGroup, State

from db import Database
from config import bot, photo_id, admin_id, user_dictionary, bot_dictionary, date_start
from markups import mainMenu

logging.basicConfig(format=u'%(filename)+13s [ LINE:%(lineno)-4s] %(levelname)-8s [%(asctime)s] %(message)s',
                    level=logging.INFO)

loop = asyncio.get_event_loop()
bot = Bot(token=bot)
dp = Dispatcher(bot, storage=MemoryStorage())

db = Database('database.db')

with open(user_dictionary, "r", encoding='utf-8') as word_list:
    user_dictionary_list = word_list.read().split('\n')


class NewGame(StatesGroup):
    line_1 = State()
    line_2 = State()
    line_3 = State()
    line_4 = State()
    line_5 = State()
    line_6 = State()


async def new_word():
    with open(bot_dictionary, "r", encoding='utf-8') as word_list:
        bot_dictionary_list = word_list.read().split('\n')
    db.add_word(random.choice(bot_dictionary_list))
    await bot.send_message(admin_id, '–ù–æ–≤–æ–µ —Å–ª–æ–≤–æ —Å–µ–≥–æ–¥–Ω—è ‚Ññ' + str((datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days) + ' - ' + db.get_word(), reply_markup=mainMenu)


async def scheduler():
    aioschedule.every().day.at("00:01").do(new_word)
    while True:
        await aioschedule.run_pending()
        await asyncio.sleep(1)


@dp.message_handler(commands=['start'])
async def start(message: types.Message):
    if not db.user_exists(message.from_user.id):
        db.add_user(message.from_user.id)
        await bot.send_photo(message.from_user.id, photo_id,
                             "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ä—É—Å—Å–∫—É—é –∞–¥–∞–ø—Ç–∞—Ü–∏—é –∏–≥—Ä—ã Wordle!\n"
                             "–£–≥–∞–¥–∞–π—Ç–µ –í–æ—Ä–¥–ª–∏ –∑–∞ 6 –ø–æ–ø—ã—Ç–æ–∫. –ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–π –æ—Ç–≥–∞–¥–∫–∏ —Ü–≤–µ—Ç –ø–ª–∏—Ç–∫–∏ –±—É–¥–µ—Ç –º–µ–Ω—è—Ç—å—Å—è, "
                             "—á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å, –Ω–∞—Å–∫–æ–ª—å–∫–æ –±–ª–∏–∑–∫–æ –í–∞—à–µ —Å–ª–æ–≤–æ –∫ –∏—Å–∫–æ–º–æ–º—É. –ü—Ä–∏–º–µ—Ä –ø—Ä–∏–≤–µ–¥–µ–Ω –Ω–∏–∂–µ.\n")
        await bot.send_message(message.from_user.id,
                               "*–ö–û–†–ö–ê*\n"
                               "üü©‚¨úÔ∏è‚¨úÔ∏èÔ∏èÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n"
                               "_–ë—É–∫–≤–∞ –ö –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–º —Å–ª–æ–≤–µ –∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –º–µ—Å—Ç–µ._\n"
                               "\n*–ü–ò–õ–û–¢*\n"
                               "‚¨úÔ∏è‚¨úÔ∏èüü®Ô∏èÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n"
                               "_–ë—É–∫–≤–∞ –õ –µ—Å—Ç—å –≤ –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–º —Å–ª–æ–≤–µ, –Ω–æ –≤ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –º–µ—Å—Ç–µ._\n"
                               "\n*–ß–ï–†–í–ò*\n"
                               "‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n"
                               "_–í—Å–µ –±—É–∫–≤—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–º —Å–ª–æ–≤–µ –Ω–∞ –ª—é–±–æ–º –º–µ—Å—Ç–µ._\n", parse_mode='Markdown',
                               reply_markup=mainMenu)
    else:
        await bot.send_message(message.from_user.id, "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑!", reply_markup=mainMenu)


@dp.message_handler(commands=['now_word'])
async def bot_now_word(message: types.Message):
    if message.from_user.id == admin_id:
        await bot.send_message(message.from_user.id,
                               db.get_word(),
                               reply_markup=mainMenu)


@dp.message_handler(commands=['new_word'])
async def bot_new_word(message: types.Message):
    if message.from_user.id == admin_id:
        await new_word()
        await bot.send_message(message.from_user.id,
                               '–í—ã –∏–∑–º–µ–Ω–∏–ª–∏ —Å–ª–æ–≤–æ!',
                               reply_markup=mainMenu)


@dp.message_handler(content_types=['text'])
async def bot_menu(message: types.Message):
    if message.text == '–ù–æ–≤–∞—è –∏–≥—Ä–∞':
        if not (datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days == db.get_played_time(message.from_user.id):
            await bot.send_message(message.from_user.id, "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å!\n"
                                                         "–í–≤–µ–¥–∏—Ç–µ –í–∞—à–µ —Å–ª–æ–≤–æ:",
                                   reply_markup=types.ReplyKeyboardRemove())
            await NewGame.line_1.set()
        else:
            await bot.send_message(message.from_user.id,
                                   "–í—ã —É–∂–µ –∏–≥—Ä–∞–ª–∏ —Å–µ–≥–æ–¥–Ω—è! –ó–∞–≤—Ç—Ä–∞ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ.",
                                   reply_markup=mainMenu)
    elif message.text == '–ü—Ä–∞–≤–∏–ª–∞':
        await bot.send_message(message.from_user.id,
                               "–£–≥–∞–¥–∞–π—Ç–µ –í–æ—Ä–¥–ª–∏ –∑–∞ 6 –ø–æ–ø—ã—Ç–æ–∫. –ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–π –æ—Ç–≥–∞–¥–∫–∏ —Ü–≤–µ—Ç –ø–ª–∏—Ç–∫–∏ –±—É–¥–µ—Ç –º–µ–Ω—è—Ç—å—Å—è, "
                               "—á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å, –Ω–∞—Å–∫–æ–ª—å–∫–æ –±–ª–∏–∑–∫–æ –í–∞—à–µ —Å–ª–æ–≤–æ –∫ –∏—Å–∫–æ–º–æ–º—É. –ü—Ä–∏–º–µ—Ä –ø—Ä–∏–≤–µ–¥–µ–Ω –Ω–∏–∂–µ.\n")
        await bot.send_message(message.from_user.id,
                               "*–ö–û–†–ö–ê*\n"
                               "üü©‚¨úÔ∏è‚¨úÔ∏èÔ∏èÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n"
                               "_–ë—É–∫–≤–∞ –ö –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–º —Å–ª–æ–≤–µ –∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –º–µ—Å—Ç–µ._\n"
                               "\n*–ü–ò–õ–û–¢*\n"
                               "‚¨úÔ∏è‚¨úÔ∏èüü®Ô∏èÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n"
                               "_–ë—É–∫–≤–∞ –õ –µ—Å—Ç—å –≤ –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–º —Å–ª–æ–≤–µ, –Ω–æ –≤ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –º–µ—Å—Ç–µ._\n"
                               "\n*–ß–ï–†–í–ò*\n"
                               "‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è‚¨úÔ∏è\n"
                               "_–í—Å–µ –±—É–∫–≤—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–º —Å–ª–æ–≤–µ –Ω–∞ –ª—é–±–æ–º –º–µ—Å—Ç–µ._\n", parse_mode='Markdown',
                               reply_markup=mainMenu)
    elif message.text == '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞':
        if db.get_played_time(message.from_user.id):
            winning = db.get_winning(message.from_user.id)
            losing = db.get_losing(message.from_user.id)
            current_streak = db.get_current_streak(message.from_user.id)
            max_streak = db.get_max_streak(message.from_user.id)
            await bot.send_message(message.from_user.id,
                                   f"–°—ã–≥—Ä–∞–Ω–æ: *{winning + losing}*\n"
                                   f"–í—ã–∏–≥—Ä—ã—à–∏: *{round(winning / (winning + losing) * 100, 1)}%*\n"
                                   f"–¢–µ–∫—É—â–∞—è —á–µ—Ä–µ–¥–∞ –ø–æ–±–µ–¥: *{current_streak}*\n"
                                   f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á–µ—Ä–µ–¥–∞ –ø–æ–±–µ–¥: *{max_streak}*\n", parse_mode='Markdown',
                                   reply_markup=mainMenu)
        else:
            await bot.send_message(message.from_user.id, "–í—ã –µ—â–µ –Ω–∏ —Ä–∞–∑—É –Ω–µ –∏–≥—Ä–∞–ª–∏!", reply_markup=mainMenu)
    else:
        await bot.send_message(message.from_user.id, "–û—à–∏–±–∫–∞!", reply_markup=mainMenu)


@dp.message_handler(content_types=['photo'])
async def bot_get_photo(message: types.Message):
    if message.from_user.id == admin_id:
        document_id = message.photo
        await bot.send_message(message.from_user.id, f"ID —Ñ–∞–π–ª–∞:\n{document_id}")


def check_line(message):
    if not bool(re.search('[–∞-—è–ê-–Ø]', message)):
        return '–í–≤–µ–¥–µ–Ω—ã –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã!\n–í–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–µ —Å–ª–æ–≤–æ:'
    elif not len(message) == 5:
        return '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –≤–≤–µ—Å—Ç–∏ —Å–ª–æ–≤–æ —Å–æ—Å—Ç–æ—è—â–∏–µ –∏–∑ 5 –±—É–∫–≤!\n–í–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–µ —Å–ª–æ–≤–æ:'
    elif not message in user_dictionary_list:
        return '–¢–∞–∫–æ–≥–æ —Å–ª–æ–≤–∞ –Ω–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ!\n–í–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–µ —Å–ª–æ–≤–æ:'
    else:
        return False


def get_blocks(message, word):
    blocks = ""
    for i, letter in enumerate(message, 0):
        if letter == word[i]:
            blocks += "üü©"
        elif word.find(letter) > -1:
            blocks += "üü®Ô∏è"
        else:
            blocks += "‚¨úÔ∏è"
    return blocks


def set_winner(id):
    db.add_winning(id)
    db.add_current_streak(id, True)
    if db.get_current_streak(id) > db.get_max_streak(id):
        db.add_max_streak(id)
    db.add_played_time(id)


@dp.message_handler(state=NewGame.line_1)
async def set_line_1(message: types.Message, state: FSMContext):
    check_result = check_line(message.text.lower())
    if check_result:
        await bot.send_message(message.from_user.id, check_result)
    else:
        async with state.proxy() as data:
            data['original_word'] = db.get_word()
            data['line_1'] = get_blocks(message.text.lower(), data['original_word'])
        if data['original_word'] == message.text.lower():
            set_winner(message.from_user.id)
            await bot.send_message(message.from_user.id, "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.")
            await bot.send_message(message.from_user.id, f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} 1/6\n\n"
                                                         f"{data['line_1']}", reply_markup=mainMenu)
            await state.finish()
        else:
            await bot.send_message(message.from_user.id, f"{data['line_1']}\n"
                                                         f"\n–í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ:")
            await NewGame.next()


@dp.message_handler(state=NewGame.line_2)
async def set_line_2(message: types.Message, state: FSMContext):
    check_result = check_line(message.text.lower())
    if check_result:
        await bot.send_message(message.from_user.id, check_result)
    else:
        async with state.proxy() as data:
            data['line_2'] = get_blocks(message.text.lower(), data['original_word'])
        if not db.get_word() == data['original_word']:
            await bot.send_message(message.from_user.id, "–°–ª–æ–≤–æ —É–∂–µ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É!", reply_markup=mainMenu)
            await state.finish()
        else:
            if data['original_word'] == message.text.lower():
                set_winner(message.from_user.id)
                await bot.send_message(message.from_user.id, "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.")
                await bot.send_message(message.from_user.id, f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} 2/6\n\n"
                                                             f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n", reply_markup=mainMenu)
                await state.finish()
            else:
                await bot.send_message(message.from_user.id, f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"\n–í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ:")
                await NewGame.next()


@dp.message_handler(state=NewGame.line_3)
async def set_line_3(message: types.Message, state: FSMContext):
    check_result = check_line(message.text.lower())
    if check_result:
        await bot.send_message(message.from_user.id, check_result)
    else:
        async with state.proxy() as data:
            data['line_3'] = get_blocks(message.text.lower(), data['original_word'])
        if not db.get_word() == data['original_word']:
            await bot.send_message(message.from_user.id, "–°–ª–æ–≤–æ —É–∂–µ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É!", reply_markup=mainMenu)
            await state.finish()
        else:
            if data['original_word'] == message.text.lower():
                set_winner(message.from_user.id)
                await bot.send_message(message.from_user.id, "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.")
                await bot.send_message(message.from_user.id, f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} 3/6\n\n"
                                                             f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n", reply_markup=mainMenu)
                await state.finish()
            else:
                await bot.send_message(message.from_user.id, f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n"
                                                             f"\n–í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ:")
                await NewGame.next()


@dp.message_handler(state=NewGame.line_4)
async def set_line_4(message: types.Message, state: FSMContext):
    check_result = check_line(message.text.lower())
    if check_result:
        await bot.send_message(message.from_user.id, check_result)
    else:
        async with state.proxy() as data:
            data['line_4'] = get_blocks(message.text.lower(), data['original_word'])
        if not db.get_word() == data['original_word']:
            await bot.send_message(message.from_user.id, "–°–ª–æ–≤–æ —É–∂–µ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É!", reply_markup=mainMenu)
            await state.finish()
        else:
            if data['original_word'] == message.text.lower():
                set_winner(message.from_user.id)
                await bot.send_message(message.from_user.id, "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.")
                await bot.send_message(message.from_user.id, f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} 4/6\n\n"
                                                             f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n"
                                                             f"{data['line_4']}\n", reply_markup=mainMenu)
                await state.finish()
            else:
                await bot.send_message(message.from_user.id, f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n"
                                                             f"{data['line_4']}\n"
                                                             f"\n–í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ:")
                await NewGame.next()


@dp.message_handler(state=NewGame.line_5)
async def set_line_5(message: types.Message, state: FSMContext):
    check_result = check_line(message.text.lower())
    if check_result:
        await bot.send_message(message.from_user.id, check_result)
    else:
        async with state.proxy() as data:
            data['line_5'] = get_blocks(message.text.lower(), data['original_word'])
        if not db.get_word() == data['original_word']:
            await bot.send_message(message.from_user.id, "–°–ª–æ–≤–æ —É–∂–µ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É!", reply_markup=mainMenu)
            await state.finish()
        else:
            if data['original_word'] == message.text.lower():
                set_winner(message.from_user.id)
                await bot.send_message(message.from_user.id, "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.")
                await bot.send_message(message.from_user.id, f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} 5/6\n\n"
                                                             f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n"
                                                             f"{data['line_4']}\n"
                                                             f"{data['line_5']}\n", reply_markup=mainMenu)
                await state.finish()
            else:
                await bot.send_message(message.from_user.id, f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n"
                                                             f"{data['line_4']}\n"
                                                             f"{data['line_5']}\n"
                                                             f"\n–í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ:")
                await NewGame.next()


@dp.message_handler(state=NewGame.line_6)
async def set_line_6(message: types.Message, state: FSMContext):
    check_result = check_line(message.text.lower())
    if check_result:
        await bot.send_message(message.from_user.id, check_result)
    else:
        async with state.proxy() as data:
            data['line_6'] = get_blocks(message.text.lower(), data['original_word'])
        if not db.get_word() == data['original_word']:
            await bot.send_message(message.from_user.id, "–°–ª–æ–≤–æ —É–∂–µ –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—É—é –∏–≥—Ä—É!", reply_markup=mainMenu)
            await state.finish()
        else:
            if data['original_word'] == message.text.lower():
                set_winner(message.from_user.id)
                await bot.send_message(message.from_user.id, "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.")
                await bot.send_message(message.from_user.id, f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} 6/6\n\n"
                                                             f"{data['line_1']}\n"
                                                             f"{data['line_2']}\n"
                                                             f"{data['line_3']}\n"
                                                             f"{data['line_4']}\n"
                                                             f"{data['line_5']}\n"
                                                             f"{data['line_6']}\n", reply_markup=mainMenu)
                await state.finish()
            else:
                db.add_losing(message.from_user.id)
                db.add_current_streak(message.from_user.id, False)
                db.add_played_time(message.from_user.id)
                await bot.send_message(message.from_user.id, f"–í—ã –Ω–µ —É–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ - {data['original_word']}")
                await bot.send_message(message.from_user.id,
                                       f"@RuWordleBot {(datetime.now() - datetime.strptime(date_start, '%Y-%m-%d')).days} X/6*\n\n"
                                       f"{data['line_1']}\n"
                                       f"{data['line_2']}\n"
                                       f"{data['line_3']}\n"
                                       f"{data['line_4']}\n"
                                       f"{data['line_5']}\n"
                                       f"{data['line_6']}\n", reply_markup=mainMenu)
                await state.finish()


async def on_startup(_):
    asyncio.create_task(scheduler())


if __name__ == '__main__':
    executor.start_polling(dp, loop=loop, skip_updates=False, on_startup=on_startup)
